<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:q,mm:v}=window,j=new q.Toolbar;j.attach(v);const we=j.render();we.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(we)})})()</script><script>((f,d,h,u)=>{const g=f();window.mm=g.Markmap.create("svg#mindmap",(d||g.deriveOptions)(u),h)})(()=>window.markmap,null,{"content":"DOM基础","children":[{"content":"节点层级","children":[{"content":"<pre><code class=\"language-html\" lang=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Sample Page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p&gt;Hello World&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","children":[]},{"content":"<img src=\"https://jsd.onmicrosoft.cn/gh/herben15/my_picture@main/img/202408191340960.png\" alt=\"image-20240819134017883\" style=\"zoom:33%;\">","children":[]}]},{"content":"Node 类型","children":[{"content":"nodeType","children":[{"content":"<pre><code class=\"language-javascript\" lang=\"javascript\">Node.ELEMENT_NODE\t\t\t\t\t(1)\t\t元素节点            　　\nNode.ATTRIBUTE_NODE\t\t\t\t\t(2)\t\t属性节点            　　\nNode.TEXT_NODE\t\t\t\t\t\t(3)\t\t文本节点            　　\nNode.CDATA_SECTION_NODE\t\t\t\t(4)\t\tCDATA节点              \nNode.ENTRY_REFERENCE_NODE\t\t\t(5)\t\t实体引用名称节点    　　 \nNode.ENTITY_NODE\t\t\t\t\t(6)\t\t实体名称节点        　　\nNode.PROCESSING_INSTRUCTION_NODE\t(7)\t\t处理指令节点        　　\nNode.COMMENT_NODE\t\t\t\t\t(8)\t\t注释节点            　 \nNode.DOCUMENT_NODE\t\t\t\t\t(9)\t\t文档节点            　 \nNode.DOCUMENT_TYPE_NODE\t\t\t\t(10)\t文档类型节点        　　\nNode.DOCUMENT_FRAGMENT_NODE\t\t\t(11)\t文档片段节点        　　\nNode.NOTATION_NODE\t\t\t\t\t(12)\tDTD声明节点            \n</code></pre>","children":[]}]},{"content":"nodeName和nodeValue","children":[]},{"content":"节点关系","children":[{"content":"childNodes属性","children":[{"content":"<img src=\"https://jsd.onmicrosoft.cn/gh/herben15/my_picture@main/img/202408191507856.png\" style=\"zoom:67%;\">","children":[]}]}]},{"content":"操纵节点","children":[{"content":"添加节点","children":[{"content":"<p>appendChild()方法：接受一个参数，用于在childNodes列表末尾添加节点，如果传入已经存在的节点，则该节点会更新到新位置。</p>","children":[]},{"content":"<p>insertBefore()方法：接受两个参数，节点和参照节点。将要插入的节点变成参照节点的前一个兄弟节点，并被返回。若是null，则与appendChild方法一致。</p>","children":[]}]},{"content":"删除节点","children":[{"content":"removeChild()方法：接受一个参数，用于删除需要移除的节点。并返回被删除的节点。","children":[]}]},{"content":"替换节点","children":[{"content":"replaceChild()方法：接受两个参数，插入节点和被替换节点。用于将替换节点删除，并将插入节点插入此位置。返回被替换节点。","children":[]}]}]},{"content":"其他方法","children":[{"content":"cloneNode()","children":[{"content":"<pre><code class=\"language-html\" lang=\"html\">&lt;ul&gt;\n    &lt;li&gt;item 1&lt;/li&gt;\n    &lt;li&gt;item 2&lt;/li&gt;\n    &lt;li&gt;item 3&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>","children":[]},{"content":"<pre><code class=\"language-javascript\" lang=\"javascript\">let deepList=myList.cloneNode(true);\t//deepList.length=3\nlet shallowList=mylist.cloneNode(false);//shallowList.length=0\n</code></pre>","children":[]}]},{"content":"normalize()","children":[]}]}]},{"content":"Document 类型","children":[{"content":"文档子节点","children":[{"content":"documentElement属性：始终指向<code>&lt;html&gt;</code>元素。","children":[]},{"content":"body属性：直接指向<code>&lt;body&gt;</code>元素。因为开发者使用的元素最多就是<code>&lt;body&gt;</code>，因此这样可以更快访问。","children":[]},{"content":"doctype属性：直接指向<code>&lt;!DOCTYPE html&gt;</code>元素。","children":[]}]},{"content":"文档信息","children":[{"content":"titile属性：包含<code>&lt;title&gt;</code>元素中的文本；可读写。","children":[]},{"content":"URL属性：包含当前网页的完整URL","children":[]},{"content":"domain属性：包含页面的域名。但已经舍弃。原可用于不同子域的窗格或内置窗格时的通信。","children":[]},{"content":"referrer属性：包含链接到当前页面的那个页面的URL，如果当前页面没有来源，则包含空字符串。","children":[]}]},{"content":"定位元素","children":[{"content":"HTMLCollection对象","children":[]},{"content":"getElementById()","children":[]},{"content":"getElementsByTagName()","children":[]},{"content":"getElementsByName()","children":[]},{"content":"getElementsByClassName()","children":[]}]},{"content":"特殊集合","children":[{"content":"document.anchors：包含文档中所有带name属性的<code>&lt;a&gt;</code>元素。","children":[]},{"content":"document.applets：包含文档纵所有<code>&lt;applet&gt;</code>元素（因为<code>&lt;applet&gt;</code>元素已经不建议使用，所以这个集合已经废弃）","children":[]},{"content":"document.forms：包含文档中所有<code>&lt;form&gt;</code>元素。","children":[]},{"content":"document.images：包含文档中所有<code>&lt;img&gt;</code>元素。","children":[]},{"content":"document.links：包含文档中所有带href属性的<code>&lt;a&gt;</code>元素","children":[]}]},{"content":"DOM兼容性检测","children":[]},{"content":"文档写入","children":[{"content":"注意特项","children":[{"content":"<p>通过文档写入的标签同样可以进行操作。与普通标签一样。</p>","children":[]},{"content":"<p>write()和writeln()方法经常用于动态包含外部资源，如JavaScript文件。但注意字符串中不能直接包含<code>&lt;/script&gt;</code>，因为这个字符串会被解释为脚本块的结尾，导致后面的代码无法运行。需要替换成<code>&lt;\\/scirpt&gt;</code>。</p>","children":[]},{"content":"<p>通常情况下是在页面渲染期间向文档中输出内容，这种情况下不会重写整个页面，而是追加。但若是在页面加载完之后再调用则输出内容会重写整个页面。</p>","children":[]}]}]}]},{"content":"Element 类型","children":[{"content":"HTML 元素","children":[]},{"content":"取得、设置、移除属性","children":[{"content":"<p>属性名不区分大小写，另外根据HTML5规范要求，自定义属性名应该加前缀<code>data-</code>以方便验证。</p>","children":[]},{"content":"<p>DOM对象可直接访问公认的属性，但自定义属性不可以直接访问，而使用getAttribute()方法等进行访问。</p>","children":[]},{"content":"<p>DOM对象访问的属性中有两个返回的值跟使用getAttribute()取得的值不一样。</p>","children":[]},{"content":"<p>开发者在进行DOM编程时通常会放弃使用<code>getAttribute()</code>而只使用对象属性。<code>getAttribute()</code>主要用于取得自定义属性的值。</p>","children":[]}]},{"content":"attributes属性","children":[{"content":"<p>NamedNodeMap对象中是一系列Attr节点，这些节点是元素的属性转化而来，要获得其属性名则用nodeName属性，要获取其属性值则用nodeValue属性。同样可以使用nodeValue属性重新设置属性值。</p>","children":[]},{"content":"<p>使用attributes属性与前面谈到的方法其实作用差不多，一个是将属性放在一个属性集合中再对属性进行操纵，而另一个则是直接在元素上进行操纵。对于开发者来说，更喜欢使用<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>方法。</p>","children":[]},{"content":"<p>attributes 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把DOM结构序列化为XML或HTML字符串。如下：</p>","children":[]}]},{"content":"创建元素","children":[{"content":"使用<code>createElement()</code>方法创建新元素的同时也会将其ownerDocument 属性设置为 document 。此时可以再为其添加属性等。","children":[]},{"content":"新元素需要使用<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>方法添加到文档中。","children":[]}]},{"content":"元素后代","children":[{"content":"<pre><code class=\"language-javascript\" lang=\"javascript\">for(let i=0;i&lt;element.childNodes.length;++i){\n    if(element.childNodes[i].nodeType==1){\n        //当为元素节点时进行操作\n    }\n}\n</code></pre>","children":[]}]}]},{"content":"Text 类型","children":[{"content":"创建文本节点","children":[{"content":"","children":[]},{"content":"创建新文本节点后，其 ownerDocument 属性会被设置为 document。注意不是在元素上使用createTextNode()方法，而是在document上使用。","children":[]},{"content":"和创建新元素一样，需要将创建的文本节点添加到文档树中。","children":[]},{"content":"在将一个文本节点作为另一个文本节点的兄弟插入后，两个文本节点的文本之间不会包含空格。","children":[]},{"content":"若是第三点的情况，则会出现多个文本节点作为兄弟，这时为了规范化文本节点，可以使用normalize()方法合并文本节点（在文本节点的父节点上使用）","children":[]}]},{"content":"拆分文本节点","children":[]}]},{"content":"Comment 类型","children":[{"content":"DOM中的注释通过Comment 类型表示。同样，它也不支持子节点。","children":[]},{"content":"Comment 类型与Text 类型继承同一个基类（CharacterData），因此拥有除splitText()之外Text 节点所有的字符串操作方法。与Text 类型相似，注释的实际内容可以通过nodeValue或data属性获得。","children":[]},{"content":"注释节点可以作为父节点的子节点来访问。","children":[]},{"content":"可以使用document.createComment()方法创建注释节点。","children":[]},{"content":"浏览器不承认结束的<code>&lt;/html&gt;</code>标签之后的注释。如果要访问注释节点，则必须确定它们是<code>&lt;html&gt;</code>元素的后代。","children":[]}]},{"content":"CDATASection 类型","children":[]},{"content":"DocumentType 类型","children":[{"content":"nodeType 等于10；","children":[]},{"content":"nodeName 值为文档类型的名称；","children":[]},{"content":"nodeValue 值为null；","children":[]},{"content":"parentNode 值为Document 对象；","children":[]},{"content":"不支持子节点。","children":[]}]},{"content":"DocumentFragment 类型","children":[{"content":"<pre><code class=\"language-javascript\" lang=\"javascript\">let fragment = document.createDocumentFragment();\n</code></pre>","children":[]},{"content":"<pre><code class=\"language-javascript\" lang=\"javascript\">let fragment = document.createDocumentFragment();\t\t\t//创建文档片段节点\nlet ul = document.getElementById(\"myList\");\t\t\t\t\t//获取ul引用\n<p data-lines=\"383,388\">for(let i=0;i&lt;3;++i){<br>\nlet li = document.createElement(\"li\");\t\t\t\t\t//创建li节点<br>\nli.appendChild(document.createTextNode(<code>Item ${i+1}</code>));\t//li节点添加文本<br>\nfragment.appendChild(li);\t\t\t\t\t\t\t\t//将li节点添加至文档片段中<br>\n}</p>\n</code><p data-lines=\"389,391\"><code class=\"language-javascript\" lang=\"javascript\">ul.appendChild(fragment);\t\t\t\t\t\t\t\t\t//将文档片段中的3个li节点同时添加到ul的下面<br>\n</code></p></pre>","children":[]}]},{"content":"Attr 类型","children":[{"content":"nodeType 等于2；","children":[]},{"content":"nodeName 值为属性名；","children":[]},{"content":"nodeValue 值为属性值；","children":[]},{"content":"parentNode 值为null；","children":[]},{"content":"在HTML中不支持子节点；","children":[]},{"content":"在XML中子节点可以是Text或EntityReference。","children":[]}]}]},null)</script>
</body>
</html>
